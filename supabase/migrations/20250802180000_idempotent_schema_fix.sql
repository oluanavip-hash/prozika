/*
# [Consolidated Schema Fix]
This migration script consolidates previous fixes and makes the schema setup idempotent to prevent conflicts with existing objects. It safely handles tables, functions, triggers, and constraints.

## Query Description:
This script will:
1. Safely drop and recreate the foreign key constraint between `product_stock` and `teams` to resolve the "already exists" error.
2. Ensure `profiles` and `product_stock` tables are created only if they don't exist.
3. Use `CREATE OR REPLACE` for functions to make them safely updatable.
4. Safely drop and recreate triggers to avoid duplication.
5. Safely drop and recreate RLS policies.
This operation is safe and will not result in data loss. It's designed to bring the database schema to a consistent and correct state.

## Metadata:
- Schema-Category: ["Structural", "Safe"]
- Impact-Level: ["Low"]
- Requires-Backup: false
- Reversible: true

## Structure Details:
- Tables affected: `profiles`, `product_stock`
- Constraints affected: `product_stock_team_id_fkey`
- Functions affected: `handle_new_user`, `update_updated_at_column`
- Triggers affected: `on_auth_user_created`, `update_profiles_updated_at`, `update_product_stock_updated_at`
- RLS Policies affected: Policies on `profiles` and `product_stock`

## Security Implications:
- RLS Status: Enabled on `profiles` and `product_stock`.
- Policy Changes: Yes, policies are dropped and recreated to ensure correctness.
- Auth Requirements: Relies on `auth.users` for triggers and user IDs.

## Performance Impact:
- Indexes: An index is created for the foreign key, which is good for performance.
- Triggers: Adds triggers for profile creation and timestamp updates. Impact is minimal and necessary for functionality.
- Estimated Impact: Low.
*/

-- 1. Create profiles table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    phone TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.profiles IS 'Stores public-facing profile information for each user.';

-- 2. Create product_stock table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.product_stock (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    team_id BIGINT NOT NULL,
    size TEXT NOT NULL,
    stock_quantity INT NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (team_id, size)
);
COMMENT ON TABLE public.product_stock IS 'Manages stock quantity for each product size.';

-- 3. Safely add foreign key constraint to product_stock
-- This is the core fix for the user's error.
ALTER TABLE public.product_stock
DROP CONSTRAINT IF EXISTS product_stock_team_id_fkey;

ALTER TABLE public.product_stock
ADD CONSTRAINT product_stock_team_id_fkey
FOREIGN KEY (team_id)
REFERENCES public.teams(id)
ON DELETE CASCADE;

-- Create an index for faster lookups
CREATE INDEX IF NOT EXISTS idx_product_stock_team_id ON public.product_stock(team_id);

-- 4. Create or replace the function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, phone)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'phone'
  );
  RETURN NEW;
END;
$$;

-- 5. Safely create the trigger on auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- 6. Create or replace the function to update the `updated_at` timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$;

-- 7. Safely create triggers for `updated_at` on relevant tables
DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles;
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_product_stock_updated_at ON public.product_stock;
CREATE TRIGGER update_product_stock_updated_at
  BEFORE UPDATE ON public.product_stock
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- 8. Enable RLS and create policies safely
-- For profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone."
  ON public.profiles FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile."
  ON public.profiles FOR INSERT
  WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile."
  ON public.profiles FOR UPDATE
  USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);

-- For product_stock table
ALTER TABLE public.product_stock ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Product stock is viewable by everyone." ON public.product_stock;
CREATE POLICY "Product stock is viewable by everyone."
  ON public.product_stock FOR SELECT
  USING (true);
